<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ä¸‰ç›®ã‚ªã‚»ãƒ­ ã‚²ãƒ¼ãƒ </title>
  <style>
    :root{
      --bg:#0f172a;        /* slate-900 */
      --panel:#111827;     /* gray-900 */
      --ink:#e5e7eb;       /* gray-200 */
      --muted:#9ca3af;     /* gray-400 */
      --accent:#22d3ee;    /* cyan-400 */
      --accent2:#a78bfa;   /* violet-400 */
      --good:#34d399;      /* emerald-400 */
      --bad:#f87171;       /* red-400 */
      --warn:#fbbf24;      /* amber-400 */
    }
    html,body{height:100%;}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 80% -10%, #1f2937 0%, var(--bg) 40% 100%);
      color: var(--ink);
      display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .wrap{ max-width:980px; width:100%; display:grid; grid-template-columns: 1fr 360px; gap:20px; }
    @media (max-width: 900px){ .wrap{ grid-template-columns: 1fr; } }

    .board{
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:20px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .grid{ display:grid; grid-template-columns: repeat(6, 1fr); gap:10px; }
    .cell{
      aspect-ratio:1 / 1; border-radius:16px; position:relative; overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background:#111827aa; backdrop-filter: blur(4px);
      display:flex; align-items:center; justify-content:center; cursor:pointer;
      font-size: clamp(28px, 6vw, 44px); font-weight: 800; letter-spacing:2px;
      transition: transform .05s ease, box-shadow .2s ease, background .2s ease;
      user-select:none;
    }
    .cell:hover{ transform: translateY(-2px); box-shadow: 0 12px 24px rgba(0,0,0,.35); }
    .cell.disabled{ cursor:not-allowed; opacity:.55; }
    .cell.O{ color: var(--accent); text-shadow: 0 0 18px #22d3ee55; }
    .cell.X{ color: var(--accent2); text-shadow: 0 0 18px #a78bfa55; }
    .hint.bad{ outline: 3px dashed var(--bad); outline-offset:-6px; }
    .hint.ok{ outline: 3px dashed var(--good); outline-offset:-6px; }

    .side{
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:20px; padding:18px; display:flex; flex-direction:column; gap:14px;
    }
    h1{ margin:0 0 4px; font-size: clamp(18px, 3.5vw, 22px); letter-spacing:.3px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge{ padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; border:1px solid rgba(255,255,255,.12); }
    .O.badge{ color: var(--bg); background: var(--accent); border-color: transparent; }
    .X.badge{ color: var(--bg); background: var(--accent2); border-color: transparent; }
    .score{ font-size: 15px; color: var(--muted); }

    .toolbar{ display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; }
    button{
      appearance:none; border:1px solid rgba(255,255,255,.12); background:#0b1220;
      color:var(--ink); padding:10px 14px; border-radius:12px; cursor:pointer;
      font-weight:700; letter-spacing:.2px; transition: transform .05s ease, background .2s;
    }
    button:hover{ transform: translateY(-1px); background:#0c1528; }
    .ghost{ background:transparent; }
    .inputBox{
      appearance:none; border:1px solid rgba(255,255,255,.12); background:#0b1220;
      color:var(--ink); padding:6px 8px; border-radius:8px; text-align:center;
      font-weight:700; letter-spacing:.2px; transition: border-color .2s;
    }

    .log{ font-size:13px; color:var(--muted); max-height:200px; overflow:auto; border-top:1px dashed rgba(255,255,255,.12); padding-top:8px; }
    .toast{ position:fixed; left:50%; top:14px; transform:translateX(-50%); background:#0b1220;
      border:1px solid rgba(255,255,255,.12); padding:8px 14px; border-radius:12px; font-weight:700; display:none; }

    .flash{
      animation: flash 750ms ease-in-out;
    }
    @keyframes flash{
      0%{ box-shadow: 0 0 0 0 rgba(34,211,238,.0); }
      40%{ box-shadow: 0 0 0 10px rgba(34,211,238,.2); }
      100%{ box-shadow: 0 0 0 0 rgba(34,211,238,.0); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="board">
      <div class="row" style="justify-content:space-between; margin-bottom:10px">
        <h1>ä¸‰ç›®ã‚ªã‚»ãƒ­ <span class="badge" id="turnBadge">å…ˆæ‰‹: <span class="O">O</span></span></h1>
        <div class="row">
          <span class="badge O">O: <b id="scoreO">0</b></span>
          <span class="badge X">X: <b id="scoreX">0</b></span>
        </div>
      </div>
      <div id="grid" class="grid"></div>
    </section>

    <aside class="side">
      <div class="row" style="justify-content:space-between">
        <div class="score">ã‚¿ãƒ¼ãƒ³: <b id="turnText">O</b></div>
        <div class="score">ç›´å‰ã®æ‰‹: <b id="lastMove">â€”</b></div>
      </div>
      <div class="toolbar">
        <label for="difficulity" style="font-size:13px;">CPUã®é›£æ˜“åº¦<br><span style="font-size:12px; color: var(--muted)">é«˜ãã™ã‚‹ã¨é‡ããªã‚Šã¾ã™</span></label>
        <input id="difficulity" type="number" min="1" max="20" value="5" style="width:48px;" class="inputBox">
      </div>
      <div class="toolbar">
        <button id="undoBtn" title="1æ‰‹æˆ»ã™">â†¶ ã‚¢ãƒ³ãƒ‰ã‚¥</button>
        <button id="resetBtn" class="ghost" title="åˆæœŸåŒ–">ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="hintsBtn" class="ghost" title="é…ç½®å¯å¦ã‚’è¡¨ç¤º">é…ç½®ãƒ’ãƒ³ãƒˆ</button>
      </div>
      <div class="log" id="log"></div>
      <details>
        <summary>ãƒ«ãƒ¼ãƒ«</summary>
        <ul>
          <li>6Ã—6ã€‚Oã¨Xã‚’äº¤äº’ã«ç½®ã„ã¦ã„ãã€‚</li>
          <li>ã‚¿ãƒ†ãƒ»ãƒ¨ã‚³ãƒ»ãƒŠãƒŠãƒ¡ã®<strong>3é€£</strong>ã”ã¨ã«1ç‚¹ï¼ˆé‡è¤‡OKï¼‰ã€‚</li>
          <li><strong>è‡ªåˆ†ã®æ—¢å­˜ãƒãƒ¼ã‚¯ã®å‘¨å›²1ãƒã‚¹</strong>ã«ã¯æ–°ã—ãç½®ã‘ãªã„ã€‚</li>
          <li>ãŸã ã—ã€<strong>è‡ªåˆ†ã®ãƒãƒ¼ã‚¯ã§ã‚¿ãƒ†ãƒ»ãƒ¨ã‚³ãƒ»ãƒŠãƒŠãƒ¡ã«æŒŸã¾ã‚ŒãŸãƒã‚¹</strong>ã¯ä¸Šã®åˆ¶é™ã‚’ç„¡è¦–ã—ã¦ç½®ã‘ã‚‹ã€‚</li>
          <li>ç½®ã‘ã‚‹ãƒã‚¹ãŒãªã‘ã‚Œã°<strong>è‡ªå‹•ã§ãƒ‘ã‚¹</strong>ã€‚</li>
          <li>ä¸¡è€…ãŒé€£ç¶šã§ãƒ‘ã‚¹ã™ã‚‹ã¨<strong>ã‚²ãƒ¼ãƒ çµ‚äº†</strong>ã—ã€å‹æ•—ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã€‚</li>
        </ul>
      </details>
      <div class="toolbar">
        <button id="mode2p">2äººå¯¾æˆ¦</button>
        <button id="modeCpu">CPUå¯¾æˆ¦</button>
      </div>
        <div class="toolbar">
            <label for="firstPlayerSelect" style="font-size:13px;">å…ˆæ‰‹</label>
            <select id="firstPlayerSelect" class="inputBox" style="width:60px;">
            <option value="O">O</option>
            <option value="X">X</option>
            </select>
        </div>
    </aside>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    const SIZE = 6;
    const DIRS8 = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    const AXES = [[1,0],[0,1],[1,1],[1,-1]];

    let board;
    let turn = 'O';
    let firstPlayer = 'O'; // å…ˆæ‰‹ï¼ˆ'O'ã¾ãŸã¯'X'ï¼‰
    let score = { O:0, X:0 };
    let awarded = { O:new Set(), X:new Set() };
    let history = [];
    let segments = [];
    let showHints = false;
    let passStreak = 0; // é€£ç¶šãƒ‘ã‚¹å›æ•°
    let difficulity = 250;
    let logEnabled = true;
    let cpuDebug = true;
    let cpuType = 1; // 0:ãã‚Œãã‚Œã®æ‰‹ã«å¯¾ã—ã¦ä¸€å®šå›æ•°ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³(åºç›¤å¼·ã„)  1: ã™ã¹ã¦ã®æ‰‹ã«å¯¾ã—ã¦ä¸€å®šå›æ•°ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³(çµ‚ç›¤å¼·ã„)



    const gridEl = document.getElementById('grid');
    const turnText = document.getElementById('turnText');
    const turnBadge = document.getElementById('turnBadge');
    const scoreO = document.getElementById('scoreO');
    const scoreX = document.getElementById('scoreX');
    const lastMove = document.getElementById('lastMove');
    const logEl = document.getElementById('log');
    const toastEl = document.getElementById('toast');

    function init(){
      board = Array.from({length:SIZE},()=>Array(SIZE).fill(''));
      score = { O:0, X:0 };
      awarded = { O:new Set(), X:new Set() };
      history = [];
      turn = firstPlayer; // â† ã“ã“ã‚’ä¿®æ­£
      passStreak = 0;
      buildSegments();
      render();
      setLog('ã‚²ãƒ¼ãƒ é–‹å§‹ã€‚' + firstPlayer + 'ã®å…ˆæ‰‹ï¼');
      if(vsCpu && turn==='X') cpuMoveMonteCarlo();
    }

    function buildSegments(){
      segments = [];
      let id = 0;
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<=SIZE-3;c++){
          segments.push({id:id++, cells:[[r,c],[r,c+1],[r,c+2]]});
        }
      }
      for(let c=0;c<SIZE;c++){
        for(let r=0;r<=SIZE-3;r++){
          segments.push({id:id++, cells:[[r,c],[r+1,c],[r+2,c]]});
        }
      }
      for(let r=0;r<=SIZE-3;r++){
        for(let c=0;c<=SIZE-3;c++){
          segments.push({id:id++, cells:[[r,c],[r+1,c+1],[r+2,c+2]]});
        }
      }
      for(let r=0;r<=SIZE-3;r++){
        for(let c=2;c<SIZE;c++){
          segments.push({id:id++, cells:[[r,c],[r+1,c-1],[r+2,c-2]]});
        }
      }
    }

    function render(){
      gridEl.innerHTML = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const v = board[r][c];
          const btn = document.createElement('button');
          btn.className = 'cell' + (v? (' ' + v):'');
          btn.dataset.r = r; btn.dataset.c = c;
          btn.textContent = v || '';
          if(v) btn.classList.add('disabled');
          if(showHints && !v){
            const ok = canPlace(r,c,turn);
            btn.classList.add('hint');
            btn.classList.add(ok?'ok':'bad');
          }
          btn.addEventListener('click', onCellClick);
          gridEl.appendChild(btn);
        }
      }
      turnText.textContent = turn;
      turnBadge.innerHTML = 'å…ˆæ‰‹: <span class="' + firstPlayer + '">' + firstPlayer + '</span>';
      turnBadge.innerHTML = 'æ‰‹ç•ª: <span class="' + turn + '">' + turn + '</span>';
      scoreO.textContent = score.O;
      scoreX.textContent = score.X;
    }

    function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

    function onCellClick(e){
      if(vsCpu && turn==='X') return;
      const r = +e.currentTarget.dataset.r;
      const c = +e.currentTarget.dataset.c;
      if(board[r][c]) return;
      if(!canPlace(r,c,turn)) {
        toast('ãã®ãƒã‚¹ã«ã¯ç½®ã‘ãªã„ã‚ˆ');
        return;
      }
      place(r,c,turn);
      const gained = awardNewPoints(turn);
      if(gained>0){ toast(turn + ' +'+gained+'ç‚¹ï¼'); }
      lastMove.textContent = `${turn} @ (${r+1},${c+1})`;
      setLog(`${turn} ãŒ (${r+1},${c+1}) ã«é…ç½®ã€‚+${gained}ç‚¹`);
      passStreak = 0; // ãƒªã‚»ãƒƒãƒˆ
      turn = (turn==='O')?'X':'O';
      checkPassOrEnd();
      render();
      if(vsCpu && turn==='X') cpuMoveMonteCarlo();
    }



    async function cpuMoveMonteCarlo(simulations = difficulity) {
      const player = 'X';
      const moves = availableMoves(player);
      if (moves.length === 0) {
        setLog(player + ' ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ã®ã§ãƒ‘ã‚¹ï¼');
        toast(player + ' ãƒ‘ã‚¹ï¼');
        passStreak++;
        if (passStreak >= 2) { endGame(); return; }
        turn = 'O';
        return;
      }

      let bestMove = null;
      let bestScore = -Infinity;

      if(cpuDebug) { console.log("=== ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœ ==="); }

      if(cpuType === 0){
          for (const move of moves) {
            let total = 0;
            for (let i = 0; i < simulations; i++) {
              total += simulateRandomPlayout(move, player);
            }
            const avg = total / simulations;

            // â˜… å„ãƒã‚¹ã”ã¨ã®ã‚¹ã‚³ã‚¢ã‚’å‡ºåŠ›
            if(cpuDebug) { console.log(`å€™è£œæ‰‹ (${move[0]+1}, ${move[1]+1}) â†’ å¹³å‡ã‚¹ã‚³ã‚¢: ${avg.toFixed(3)} (è©¦è¡Œ${simulations}å›)`); }

            if (avg > bestScore) {
              bestScore = avg;
              bestMove = move;
            }
          }
      } else if (cpuType === 1){
          let dividedSimulations = Math.ceil(simulations / moves.length);
          for (const move of moves) {
            let total = 0;
            for (let i = 0; i < dividedSimulations; i++) {
              total += simulateRandomPlayout(move, player);
            }
            const avg = total / dividedSimulations;

            // â˜… å„ãƒã‚¹ã”ã¨ã®ã‚¹ã‚³ã‚¢ã‚’å‡ºåŠ›
            if(cpuDebug) { console.log(`å€™è£œæ‰‹ (${move[0]+1}, ${move[1]+1}) â†’ å¹³å‡ã‚¹ã‚³ã‚¢: ${avg.toFixed(3)} (è©¦è¡Œ${dividedSimulations}å›)`); }

            if (avg > bestScore) {
              bestScore = avg;
              bestMove = move;
            }
          }
      } else {
          console.error("ãã‚“ãªcpuTypeã¯ã‚ã‚Šã¾ã›ã‚“:", cpuType);
          return;
      }

      if(cpuDebug) {
        console.log(`ğŸ‘‰ æ¡ç”¨æ‰‹: (${bestMove[0]+1}, ${bestMove[1]+1}) å¹³å‡ã‚¹ã‚³ã‚¢=${bestScore.toFixed(3)}`);
        console.log("=====================================");
      }

      // å®Ÿéš›ã«ç½®ã
      const [r, c] = bestMove;
      place(r, c, player);
      const gained = awardNewPoints(player);
      if (gained > 0) { toast(player + ' +' + gained + 'ç‚¹ï¼'); }
      lastMove.textContent = `${player} @ (${r+1},${c+1})`;
      setLog(`${player} ãŒ (${r+1},${c+1}) ã«é…ç½®ã€‚+${gained}ç‚¹`);
      passStreak = 0;
      turn = 'O';
      render();
      checkPassOrEnd();
    }


    function simulateRandomPlayout(firstMove, player) {
      // ç›¤é¢ã¨ã‚¹ã‚³ã‚¢ã‚’ã‚³ãƒ”ãƒ¼
      const simBoard = board.map(row => row.slice());
      const simAwarded = { O: new Set(awarded.O), X: new Set(awarded.X) };
      const simScore = { O: score.O, X: score.X };

      // æœ€åˆã®æ‰‹ã‚’ç½®ã
      const [r, c] = firstMove;
      simBoard[r][c] = player;
      simScore[player] += simulateScore(simBoard, r, c, player, simAwarded);

      // æ®‹ã‚Šã¯çµ‚å±€ã¾ã§ãƒ©ãƒ³ãƒ€ãƒ ãƒ—ãƒ¬ã‚¤
      let cur = (player === 'O') ? 'X' : 'O';
      let passes = 0;
      while (passes < 2) {
        // ç½®ã‘ã‚‹æ‰‹ã‚’åˆ—æŒ™
        const moves = [];
        for (let rr = 0; rr < SIZE; rr++) {
          for (let cc = 0; cc < SIZE; cc++) {
            if (canPlaceSim(rr, cc, cur, simBoard)) moves.push([rr, cc]);
          }
        }

        if (moves.length === 0) {
          // ãƒ‘ã‚¹
          passes++;
          cur = (cur === 'O') ? 'X' : 'O';
          continue;
        }

        passes = 0; // ãƒªã‚»ãƒƒãƒˆ
        const [rr, cc] = moves[Math.floor(Math.random() * moves.length)];
        simBoard[rr][cc] = cur;
        simScore[cur] += simulateScore(simBoard, rr, cc, cur, simAwarded);

        // æ‰‹ç•ªäº¤ä»£
        cur = (cur === 'O') ? 'X' : 'O';
      }

      // æœ€çµ‚çš„ã«å‹æ•—ã§ã‚¹ã‚³ã‚¢ã‚’è¿”ã™
      if (simScore.X > simScore.O) return 1;
      if (simScore.X < simScore.O) return -1;
      return 0;
    }




    function canPlaceSim(r, c, p, simBoard) {
      if (simBoard[r][c]) return false;

      // æŒŸã¿è¾¼ã¿ãªã‚‰ä¾‹å¤–çš„ã«OK
      if (isSandwichedSim(r, c, p, simBoard)) return true;

      // é€šå¸¸ã®ç¦æ­¢ãƒ«ãƒ¼ãƒ«ï¼ˆéš£æ¥ã«è‡ªåˆ†ãŒã‚ã‚‹ã¨ç½®ã‘ãªã„ï¼‰
      for (const [dr, dc] of DIRS8) {
        const nr = r + dr, nc = c + dc;
        if (inBounds(nr, nc) && simBoard[nr][nc] === p) return false;
      }
      return true;
    }

    function isSandwichedSim(r, c, p, simBoard) {
      for (const [dr,dc] of AXES){
        let hasPos=false, hasNeg=false;
        let rr=r+dr, cc=c+dc;
        while(inBounds(rr,cc)){
          if(simBoard[rr][cc]===p){ hasPos=true; break; }
          rr+=dr; cc+=dc;
        }
        rr=r-dr; cc=c-dc;
        while(inBounds(rr,cc)){
          if(simBoard[rr][cc]===p){ hasNeg=true; break; }
          rr-=dr; cc-=dc;
        }
        if(hasPos && hasNeg) return true;
      }
      return false;
    }



      function simulateScore(simBoard,r,c,p,simAwarded){
        let gained=0;
        for(const seg of segments){
          const ok = seg.cells.every(([rr,cc])=>simBoard[rr][cc]===p);
          if(!ok) continue;
          if(!simAwarded[p].has(seg.id)){ simAwarded[p].add(seg.id); gained++; }
        }
        return gained;
      }




    function place(r,c,p){
      board[r][c] = p;
      history.push({ r,c, player:p, newly:[] });
    }

    function canPlace(r,c,p){
      if(board[r][c]) return false;
      const sandwiched = isSandwiched(r,c,p);
      if(sandwiched) return true;
      for(const [dr,dc] of DIRS8){
        const nr=r+dr, nc=c+dc;
        if(inBounds(nr,nc) && board[nr][nc]===p) return false;
      }
      return true;
    }

    function isSandwiched(r,c,p){
      for(const [dr,dc] of AXES){
        let hasPos=false, hasNeg=false;
        let rr=r+dr, cc=c+dc;
        while(inBounds(rr,cc)){
          if(board[rr][cc]===p){ hasPos=true; break; }
          rr+=dr; cc+=dc;
        }
        rr=r-dr; cc=c-dc;
        while(inBounds(rr,cc)){
          if(board[rr][cc]===p){ hasNeg=true; break; }
          rr-=dr; cc-=dc;
        }
        if(hasPos && hasNeg) return true;
      }
      return false;
    }

    function awardNewPoints(p){
      let gained = 0;
      for(const seg of segments){
        const ok = seg.cells.every(([r,c])=>board[r][c]===p);
        if(!ok) continue;
        if(!awarded[p].has(seg.id)){
          awarded[p].add(seg.id);
          gained++;
          if(history.length>0){ history[history.length-1].newly.push(seg.id); }
        }
      }
      score[p] += gained;
      return gained;
    }

    function undo(){
      const h = history.pop();
      if(!h) { toast('æˆ»ã™æ‰‹ãŒãªã„ã‚ˆ'); return; }
      board[h.r][h.c] = '';
      if(h.newly && h.newly.length){
        for(const id of h.newly){
          awarded[h.player].delete(id);
          score[h.player] -= 1;
        }
      }
      turn = h.player;
      lastMove.textContent = 'â€”';
      setLog(`ã‚¢ãƒ³ãƒ‰ã‚¥: ${h.player} ã®æ‰‹ã‚’å–ã‚Šæ¶ˆã—`);
      render();
    }

    function reset(){ init(); lastMove.textContent='â€”'; }

    function setLog(msg){
          if(!logEnabled) return;
      const time = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.textContent = `[${time}] ${msg}`;
      logEl.prepend(line);

      // æœ€å¤§100è¡Œã¾ã§
      while(logEl.childNodes.length > 100){
        logEl.removeChild(logEl.lastChild);
      }
    }

    function toast(msg){
      toastEl.textContent = msg; toastEl.style.display='block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.style.display='none', 1300);
    }

    function checkPassOrEnd(){
      const moves = availableMoves(turn);
      if(moves.length===0){
        setLog(turn+' ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ã®ã§ãƒ‘ã‚¹ï¼');
        toast(turn+' ãƒ‘ã‚¹ï¼');
        passStreak++;
        if(passStreak>=2){
          endGame();
          return;
        }
        turn = (turn==='O')?'X':'O';
        if(vsCpu && turn==='X') cpuMoveMonteCarlo();
        checkPassOrEnd();
      }
    }

    function availableMoves(p){
      const res=[];
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          if(canPlace(r,c,p)) res.push([r,c]);
        }
      }
      return res;
    }

    function endGame(){
      let msg;
      if(score.O>score.X){ msg='Oã®å‹ã¡ï¼'; }
      else if(score.X>score.O){ msg='Xã®å‹ã¡ï¼'; }
      else { msg='å¼•ãåˆ†ã‘ï¼'; }
      setLog('ã‚²ãƒ¼ãƒ çµ‚äº†: '+msg);
      toast('ã‚²ãƒ¼ãƒ çµ‚äº†: '+msg);
    }

    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('resetBtn').addEventListener('click', reset);
    document.getElementById('hintsBtn').addEventListener('click', ()=>{ showHints=!showHints; render(); });
    document.getElementById('mode2p').addEventListener('click',()=>{ vsCpu=false; init(); });
    document.getElementById('modeCpu').addEventListener('click',()=>{ vsCpu=true; init(); });
    
    document.getElementById('difficulity').addEventListener('change', function(e){
      let v = parseInt(e.target.value, 10);
      if(isNaN(v) || v < 1) v = 1;
      if(v > 20) v = 20;
      difficulity = v * v * 10 * (1 + cpuType * 9);
      e.target.value = v; // ç¯„å›²å¤–å…¥åŠ›æ™‚ã‚‚è£œæ­£
      setLog('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆå›æ•°ã‚’ ' + difficulity + 'å› ã«å¤‰æ›´ã—ã¾ã—ãŸ');
    });

    document.getElementById('firstPlayerSelect').addEventListener('change', function(e){
        firstPlayer = e.target.value;
        setLog('å…ˆæ‰‹ã‚’ ' + firstPlayer + ' ã«å¤‰æ›´ã—ã¾ã—ãŸ');
        init();
    });


    vsCpu=false
    init();
  </script>
</body>
</html>
